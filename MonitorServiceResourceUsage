可以的，我將新增日誌檔案保留期限功能，預設為 15 天。讓我們更新代碼來實現這一點。

### 1. 更新 ConfigurationManager.cs 添加保留期限設定

```csharp
using System;
using System.Collections.Generic;
using System.IO;
using Microsoft.Extensions.Configuration;

namespace ProcessMonitor
{
    /// <summary>
    /// Manages application configuration settings from appsettings.json
    /// </summary>
    public static class ConfigurationManager
    {
        private static IConfiguration _configuration;
        
        // Configuration settings
        public static string LogFolderPath { get; private set; }
        public static bool OutputToConsole { get; private set; }
        public static bool OutputToFile { get; private set; }
        public static int MonitorIntervalSeconds { get; private set; }
        public static int ProcessCount { get; private set; }
        public static bool DetailedCpuMeasurement { get; private set; }
        public static bool ShowMemoryRanking { get; private set; }
        public static bool ShowDetailedProcessInfo { get; private set; }
        public static int LogRetentionDays { get; private set; }

        /// <summary>
        /// Initialize configuration settings from appsettings.json
        /// </summary>
        public static void Initialize()
        {
            try
            {
                // Build configuration from appsettings.json
                _configuration = new ConfigurationBuilder()
                    .SetBasePath(Directory.GetCurrentDirectory())
                    .AddJsonFile("appsettings.json", optional: false, reloadOnChange: true)
                    .Build();
                
                // Get "ProcessMonitorSettings" section
                var settings = _configuration.GetSection("ProcessMonitorSettings");
                
                // Read config values with defaults
                LogFolderPath = settings["LogFolderPath"] ?? 
                    Path.Combine(Directory.GetCurrentDirectory(), "logs");
                    
                OutputToConsole = settings.GetValue<bool?>("OutputToConsole") ?? true;
                OutputToFile = settings.GetValue<bool?>("OutputToFile") ?? true;
                MonitorIntervalSeconds = settings.GetValue<int?>("MonitorIntervalSeconds") ?? 60;
                ProcessCount = settings.GetValue<int?>("ProcessCount") ?? 10;
                DetailedCpuMeasurement = settings.GetValue<bool?>("DetailedCpuMeasurement") ?? true;
                ShowMemoryRanking = settings.GetValue<bool?>("ShowMemoryRanking") ?? true;
                ShowDetailedProcessInfo = settings.GetValue<bool?>("ShowDetailedProcessInfo") ?? true;
                LogRetentionDays = settings.GetValue<int?>("LogRetentionDays") ?? 15;
                
                // Validate settings
                if (LogRetentionDays < 1)
                {
                    Console.WriteLine("Warning: LogRetentionDays must be at least 1. Setting to default (15).");
                    LogRetentionDays = 15;
                }
                
                // Ensure log directory exists if we're outputting to file
                if (OutputToFile && !Directory.Exists(LogFolderPath))
                {
                    Directory.CreateDirectory(LogFolderPath);
                    Console.WriteLine($"Created log directory: {LogFolderPath}");
                }
            }
            catch (Exception ex)
            {
                // If there's an error reading config, use default values and log the error
                Console.WriteLine($"Error reading configuration: {ex.Message}. Using default values.");
                
                // Set default values
                LogFolderPath = Path.Combine(Directory.GetCurrentDirectory(), "logs");
                OutputToConsole = true;
                OutputToFile = true;
                MonitorIntervalSeconds = 60;
                ProcessCount = 10;
                DetailedCpuMeasurement = true;
                ShowMemoryRanking = true;
                ShowDetailedProcessInfo = true;
                LogRetentionDays = 15;
                
                // Create logs directory with default values
                try
                {
                    if (OutputToFile && !Directory.Exists(LogFolderPath))
                    {
                        Directory.CreateDirectory(LogFolderPath);
                        Console.WriteLine($"Created log directory: {LogFolderPath}");
                    }
                }
                catch (Exception dirEx)
                {
                    Console.WriteLine($"Failed to create log directory: {dirEx.Message}");
                } 
            }
        }
        
        /// <summary>
        /// Gets the raw configuration object for advanced usage
        /// </summary>
        public static IConfiguration GetRawConfiguration()
        {
            return _configuration;
        }
    }
}
```

### 2. 更新 ReportManager.cs 實現日誌清理功能

```csharp
using System;
using System.IO;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Linq;

namespace ProcessMonitor
{
    /// <summary>
    /// Responsible for handling output of monitoring reports
    /// </summary>
    public class ReportManager
    {
        // Keep track of when we last cleaned up old logs
        private static DateTime _lastLogCleanupTime = DateTime.MinValue;
        
        /// <summary>
        /// Output a monitoring report to configured destinations
        /// </summary>
        /// <param name="reportText">The report text to output</param>
        /// <param name="timestamp">Timestamp for the report</param>
        /// <param name="cancellationToken">Cancellation token</param>
        public async Task OutputReportAsync(string reportText, DateTime timestamp, CancellationToken cancellationToken)
        {
            if (ConfigurationManager.OutputToConsole)
            {
                OutputToConsole(reportText);
            }
            
            if (ConfigurationManager.OutputToFile)
            {
                await OutputToFileAsync(reportText, timestamp, cancellationToken);
                
                // Clean up old log files once per day
                if ((DateTime.Now - _lastLogCleanupTime).TotalHours >= 24)
                {
                    await CleanupOldLogsAsync(cancellationToken);
                    _lastLogCleanupTime = DateTime.Now;
                }
            }
        }
        
        /// <summary>
        /// Output the report to the console
        /// </summary>
        private void OutputToConsole(string reportText)
        {
            try
            {
                Console.Clear();
                Console.WriteLine(reportText);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error writing to console: {ex.Message}");
            }
        }
        
        /// <summary>
        /// Output the report to a log file
        /// </summary>
        private async Task OutputToFileAsync(string reportText, DateTime timestamp, CancellationToken cancellationToken)
        {
            try
            {
                // Ensure log directory exists
                if (!Directory.Exists(ConfigurationManager.LogFolderPath))
                {
                    try
                    {
                        Directory.CreateDirectory(ConfigurationManager.LogFolderPath);
                        Console.WriteLine($"Created log directory: {ConfigurationManager.LogFolderPath}");
                    }
                    catch (Exception dirEx)
                    {
                        Console.WriteLine($"Failed to create log directory: {dirEx.Message}");
                        return; // Cannot proceed without a log directory
                    }
                }
                
                // Create timestamped filename
                string filename = $"ProcessMonitor_{timestamp.ToString("yyyy-MM-dd")}.log";
                string filePath = Path.Combine(ConfigurationManager.LogFolderPath, filename);
                
                // Write to the file
                using (StreamWriter writer = new StreamWriter(filePath, true, Encoding.UTF8))
                {
                    await writer.WriteLineAsync(reportText);
                    await writer.FlushAsync();
                }
                
                Console.WriteLine($"Report saved to: {filePath}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error writing report to file: {ex.Message}");
            }
        }
        
        /// <summary>
        /// Clean up log files older than the retention period
        /// </summary>
        private async Task CleanupOldLogsAsync(CancellationToken cancellationToken)
        {
            try
            {
                // Calculate the cutoff date for log retention
                DateTime cutoffDate = DateTime.Now.AddDays(-ConfigurationManager.LogRetentionDays);
                
                // Get all log files
                DirectoryInfo logDir = new DirectoryInfo(ConfigurationManager.LogFolderPath);
                if (!logDir.Exists)
                    return;
                
                // Find files older than the cutoff date
                var oldFiles = logDir.GetFiles("ProcessMonitor_*.log")
                    .Where(f => f.LastWriteTime < cutoffDate)
                    .ToList();
                
                if (oldFiles.Count > 0)
                {
                    Console.WriteLine($"Cleaning up {oldFiles.Count} log files older than {ConfigurationManager.LogRetentionDays} days...");
                    
                    // Delete old files
                    foreach (var file in oldFiles)
                    {
                        try
                        {
                            // Check for cancellation
                            cancellationToken.ThrowIfCancellationRequested();
                            
                            // Delete the file
                            file.Delete();
                            
                            // Pause briefly to avoid overwhelming the file system
                            await Task.Delay(20, cancellationToken);
                        }
                        catch (OperationCanceledException)
                        {
                            throw; // Rethrow cancellation exception
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine($"Failed to delete old log file {file.Name}: {ex.Message}");
                        }
                    }
                    
                    Console.WriteLine("Log cleanup completed.");
                }
            }
            catch (OperationCanceledException)
            {
                // Just bubble up cancellation exceptions
                throw;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error during log cleanup: {ex.Message}");
            }
        }
    }
}
```

### 3. 更新 appsettings.json 添加保留期限設定

```json
{
  "ProcessMonitorSettings": {
    "LogFolderPath": "logs",
    "OutputToConsole": true,
    "OutputToFile": true,
    "MonitorIntervalSeconds": 60,
    "ProcessCount": 10,
    "DetailedCpuMeasurement": true,
    "ShowMemoryRanking": true,
    "ShowDetailedProcessInfo": true,
    "LogRetentionDays": 15
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "System": "Warning"
    }
  }
}
```

### 4. 更新 Program.cs 顯示日誌保留期限信息

```csharp
using System;
using System.Threading;
using System.Threading.Tasks;

namespace ProcessMonitor
{
    class Program
    {
        private static CancellationTokenSource _cancellationTokenSource;

        static async Task Main(string[] args)
        {
            try
            {
                // Initialize application configuration from appsettings.json
                ConfigurationManager.Initialize();
                
                // Create cancellation token source for graceful shutdown
                _cancellationTokenSource = new CancellationTokenSource();

                // Handle Ctrl+C to gracefully exit
                Console.CancelKeyPress += (sender, e) => {
                    e.Cancel = true;
                    _cancellationTokenSource.Cancel();
                    Console.WriteLine("Shutting down...");
                };
                
                // Display startup message
                DisplayStartupInfo();
                
                // Main monitoring loop
                MonitoringEngine monitor = new MonitoringEngine();
                await monitor.StartMonitoringAsync(_cancellationTokenSource.Token);
                
                Console.WriteLine("Process monitor has been shut down.");
            }
            catch (Exception ex)
            {
                // Handle any unhandled exceptions
                Console.WriteLine($"Fatal error: {ex.Message}");
                Console.WriteLine($"Stack trace: {ex.StackTrace}");
                Console.WriteLine("Press any key to exit...");
                Console.ReadKey();
            }
        }
        
        private static void DisplayStartupInfo()
        {
            Console.WriteLine("Process Resource Monitor Started...");
            Console.WriteLine($"Time: {DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss")}");
            Console.WriteLine($"Monitoring top {ConfigurationManager.ProcessCount} processes every {ConfigurationManager.MonitorIntervalSeconds} seconds");
            Console.WriteLine($"Output to console: {ConfigurationManager.OutputToConsole}");
            Console.WriteLine($"Output to file: {ConfigurationManager.OutputToFile}");
            if (ConfigurationManager.OutputToFile)
            {
                Console.WriteLine($"Log folder: {ConfigurationManager.LogFolderPath}");
                Console.WriteLine($"Log retention: {ConfigurationManager.LogRetentionDays} days");
            }
            Console.WriteLine($"Detailed CPU measurement: {ConfigurationManager.DetailedCpuMeasurement}");
            Console.WriteLine($"Show memory ranking: {ConfigurationManager.ShowMemoryRanking}");
            Console.WriteLine($"Show detailed process info: {ConfigurationManager.ShowDetailedProcessInfo}");
            Console.WriteLine("Note: Non-administrator privileges may limit access to system processes\n");
        }
    }
}
```

### 功能說明

1. **日誌檔案保留期限**
   - 添加新配置選項 `LogRetentionDays`，默認值為 15 天
   - 當寫入日誌檔案時，檢查是否需要進行清理（每 24 小時檢查一次）
   - 清理所有超過保留天數的日誌檔案

2. **實現方式**
   - 使用 `LastWriteTime` 檢查檔案創建/修改時間
   - 只刪除匹配模式 `ProcessMonitor_*.log` 的檔案
   - 在 ReportManager 中實現異步清理方法

3. **錯誤處理和通知**
   - 如果清理過程中出現錯誤，會顯示詳細的錯誤信息
   - 在啟動時顯示日誌保留設置，以及在清理時顯示清理情況

4. **效能考慮**
   - 清理過程是異步執行的，不會阻塞主程序
   - 刪除檔案時添加了短暫延遲，避免密集的檔案系統操作
   - 只在每 24 小時檢查一次，避免不必要的檔案系統掃描

這個功能確保日誌檔案不會無限制增長，並自動刪除超過 15 天（或用戶配置的其他天數）的舊日誌。這樣可以避免磁碟空間被舊的、不再需要的日誌檔案填滿，同時仍保留最近的日誌供參考和故障排查。

用戶可以通過修改 appsettings.json 中的 LogRetentionDays 值來自定義保留期限。