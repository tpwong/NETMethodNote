好的，我將實現以 CSV 格式輸出進程資訊的功能。讓我們新增一個 CSVReportManager 來處理這個功能。

### 1. 新增 ReportFormat 枚舉選項到 ConfigurationManager.cs

```csharp
using System;
using System.Collections.Generic;
using System.IO;
using Microsoft.Extensions.Configuration;

namespace ProcessMonitor
{
    /// <summary>
    /// Output report format options
    /// </summary>
    public enum ReportFormat
    {
        Text,
        CSV
    }
    
    /// <summary>
    /// Manages application configuration settings from appsettings.json
    /// </summary>
    public static class ConfigurationManager
    {
        private static IConfiguration _configuration;
        
        // Configuration settings
        public static string LogFolderPath { get; private set; }
        public static bool OutputToConsole { get; private set; }
        public static bool OutputToFile { get; private set; }
        public static int MonitorIntervalSeconds { get; private set; }
        public static int ProcessCount { get; private set; }
        public static bool DetailedCpuMeasurement { get; private set; }
        public static bool ShowMemoryRanking { get; private set; }
        public static bool ShowDetailedProcessInfo { get; private set; }
        public static int LogRetentionDays { get; private set; }
        public static int CpuUpdateIntervalMs { get; private set; }
        public static ReportFormat OutputFormat { get; private set; }

        /// <summary>
        /// Initialize configuration settings from appsettings.json
        /// </summary>
        public static void Initialize()
        {
            try
            {
                // Build configuration from appsettings.json
                _configuration = new ConfigurationBuilder()
                    .SetBasePath(Directory.GetCurrentDirectory())
                    .AddJsonFile("appsettings.json", optional: false, reloadOnChange: true)
                    .Build();
                
                // Get "ProcessMonitorSettings" section
                var settings = _configuration.GetSection("ProcessMonitorSettings");
                
                // Read config values with defaults
                LogFolderPath = settings["LogFolderPath"] ?? 
                    Path.Combine(Directory.GetCurrentDirectory(), "logs");
                    
                OutputToConsole = settings.GetValue<bool?>("OutputToConsole") ?? true;
                OutputToFile = settings.GetValue<bool?>("OutputToFile") ?? true;
                MonitorIntervalSeconds = settings.GetValue<int?>("MonitorIntervalSeconds") ?? 60;
                ProcessCount = settings.GetValue<int?>("ProcessCount") ?? 10;
                DetailedCpuMeasurement = settings.GetValue<bool?>("DetailedCpuMeasurement") ?? true;
                ShowMemoryRanking = settings.GetValue<bool?>("ShowMemoryRanking") ?? true;
                ShowDetailedProcessInfo = settings.GetValue<bool?>("ShowDetailedProcessInfo") ?? true;
                LogRetentionDays = settings.GetValue<int?>("LogRetentionDays") ?? 15;
                CpuUpdateIntervalMs = settings.GetValue<int?>("CpuUpdateIntervalMs") ?? 200;
                
                // Parse report format
                string formatStr = settings["OutputFormat"] ?? "CSV";
                if (Enum.TryParse<ReportFormat>(formatStr, true, out var format))
                {
                    OutputFormat = format;
                }
                else
                {
                    OutputFormat = ReportFormat.CSV; // Default to CSV if parsing fails
                    Console.WriteLine($"Warning: Invalid OutputFormat '{formatStr}'. Using CSV format.");
                }
                
                // Validate settings
                if (LogRetentionDays < 1)
                {
                    Console.WriteLine("Warning: LogRetentionDays must be at least 1. Setting to default (15).");
                    LogRetentionDays = 15;
                }
                
                if (CpuUpdateIntervalMs < 100)
                {
                    Console.WriteLine("Warning: CpuUpdateIntervalMs must be at least 100ms. Setting to default (200ms).");
                    CpuUpdateIntervalMs = 200;
                }
                
                // Ensure log directory exists if we're outputting to file
                if (OutputToFile && !Directory.Exists(LogFolderPath))
                {
                    Directory.CreateDirectory(LogFolderPath);
                    Console.WriteLine($"Created log directory: {LogFolderPath}");
                }
            }
            catch (Exception ex)
            {
                // If there's an error reading config, use default values and log the error
                Console.WriteLine($"Error reading configuration: {ex.Message}. Using default values.");
                
                // Set default values
                LogFolderPath = Path.Combine(Directory.GetCurrentDirectory(), "logs");
                OutputToConsole = true;
                OutputToFile = true;
                MonitorIntervalSeconds = 60;
                ProcessCount = 10;
                DetailedCpuMeasurement = true;
                ShowMemoryRanking = true;
                ShowDetailedProcessInfo = true;
                LogRetentionDays = 15;
                CpuUpdateIntervalMs = 200;
                OutputFormat = ReportFormat.CSV;
                
                // Create logs directory with default values
                try
                {
                    if (OutputToFile && !Directory.Exists(LogFolderPath))
                    {
                        Directory.CreateDirectory(LogFolderPath);
                        Console.WriteLine($"Created log directory: {LogFolderPath}");
                    }
                }
                catch (Exception dirEx)
                {
                    Console.WriteLine($"Failed to create log directory: {dirEx.Message}");
                } 
            }
        }
        
        /// <summary>
        /// Gets the raw configuration object for advanced usage
        /// </summary>
        public static IConfiguration GetRawConfiguration()
        {
            return _configuration;
        }
    }
}
```

### 2. 重寫 ReportManager.cs 來支援 CSV 報告格式

```csharp
using System;
using System.IO;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Linq;
using System.Collections.Generic;
using System.Globalization;

namespace ProcessMonitor
{
    /// <summary>
    /// Responsible for handling output of monitoring reports
    /// </summary>
    public class ReportManager
    {
        // Keep track of when we last cleaned up old logs
        private static DateTime _lastLogCleanupTime = DateTime.MinValue;
        
        /// <summary>
        /// Output a monitoring report to configured destinations
        /// </summary>
        /// <param name="processResources">The list of process resources to output</param>
        /// <param name="timestamp">Timestamp for the report</param>
        /// <param name="cancellationToken">Cancellation token</param>
        public async Task OutputReportAsync(List<ProcessResourceInfo> processResources, 
                                           DateTime timestamp, 
                                           CancellationToken cancellationToken)
        {
            // Create the appropriate report based on the configured format
            string report;
            string fileExtension;
            
            if (ConfigurationManager.OutputFormat == ReportFormat.CSV)
            {
                report = GenerateCSVReport(processResources, timestamp);
                fileExtension = "csv";
            }
            else
            {
                report = GenerateTextReport(processResources, timestamp);
                fileExtension = "log";
            }
            
            if (ConfigurationManager.OutputToConsole)
            {
                OutputToConsole(report);
            }
            
            if (ConfigurationManager.OutputToFile)
            {
                await OutputToFileAsync(report, timestamp, fileExtension, cancellationToken);
                
                // Clean up old log files once per day
                if ((DateTime.Now - _lastLogCleanupTime).TotalHours >= 24)
                {
                    await CleanupOldLogsAsync(cancellationToken);
                    _lastLogCleanupTime = DateTime.Now;
                }
            }
        }
        
        /// <summary>
        /// Generates a CSV format report
        /// </summary>
        private string GenerateCSVReport(List<ProcessResourceInfo> processResources, DateTime timestamp)
        {
            StringBuilder csv = new StringBuilder();
            
            // Add timestamp row
            csv.AppendLine($"Timestamp,{timestamp.ToString("yyyy-MM-dd HH:mm:ss")}");
            csv.AppendLine($"Total Processes,{processResources.Count}");
            csv.AppendLine($"Total Memory (MB),{processResources.Sum(p => p.MemoryUsageMB):F2}");
            csv.AppendLine();
            
            // Add CSV headers
            csv.AppendLine("Rank,Process Name,PID,CPU (%),Memory (MB),Memory (%),Start Time,Description,Service");
            
            // Sort by CPU usage and add top processes
            var topCpuProcesses = processResources
                .OrderByDescending(p => p.CpuUsage)
                .Take(ConfigurationManager.ProcessCount)
                .ToList();
                
            for (int i = 0; i < topCpuProcesses.Count; i++)
            {
                var proc = topCpuProcesses[i];
                csv.AppendLine(FormatCSVRow(i + 1, proc));
            }
            
            // Add a separator before memory section if enabled
            if (ConfigurationManager.ShowMemoryRanking)
            {
                csv.AppendLine();
                csv.AppendLine("Memory Ranking");
                csv.AppendLine("Rank,Process Name,PID,CPU (%),Memory (MB),Memory (%),Start Time,Description,Service");
                
                // Sort by memory usage and add top processes
                var topMemoryProcesses = processResources
                    .OrderByDescending(p => p.MemoryUsageMB)
                    .Take(ConfigurationManager.ProcessCount)
                    .ToList();
                    
                for (int i = 0; i < topMemoryProcesses.Count; i++)
                {
                    var proc = topMemoryProcesses[i];
                    csv.AppendLine(FormatCSVRow(i + 1, proc));
                }
            }
            
            return csv.ToString();
        }
        
        /// <summary>
        /// Format a process information row for CSV
        /// </summary>
        private string FormatCSVRow(int rank, ProcessResourceInfo proc)
        {
            // Properly escape CSV fields to handle commas and quotes
            return $"{rank}," +
                   $"{EscapeCSV(proc.ProcessName)}," +
                   $"{proc.ProcessId}," +
                   $"{proc.CpuUsage.ToString("F2", CultureInfo.InvariantCulture)}," +
                   $"{proc.MemoryUsageMB.ToString("F2", CultureInfo.InvariantCulture)}," +
                   $"{proc.MemoryUsagePercent.ToString("F2", CultureInfo.InvariantCulture)}," +
                   $"{EscapeCSV(proc.StartTime)}," +
                   $"{EscapeCSV(proc.Description)}," +
                   $"{EscapeCSV(proc.ServiceName)}";
        }
        
        /// <summary>
        /// Escape a string for CSV format
        /// </summary>
        private string EscapeCSV(string field)
        {
            if (string.IsNullOrEmpty(field))
                return string.Empty;
                
            // If the field contains a comma, newline, or quote, wrap it in quotes
            if (field.Contains(",") || field.Contains("\"") || field.Contains("\r") || field.Contains("\n"))
            {
                // Replace any quotes with double quotes
                field = field.Replace("\"", "\"\"");
                
                // Wrap the field in quotes
                return $"\"{field}\"";
            }
            
            return field;
        }
        
        /// <summary>
        /// Generates a text format report (original format)
        /// </summary>
        private string GenerateTextReport(List<ProcessResourceInfo> processResources, DateTime timestamp)
        {
            StringBuilder report = new StringBuilder();
            
            // Generate report heading
            report.AppendLine($"===== Process Resource Monitor Report =====");
            report.AppendLine($"Time: {timestamp.ToString("yyyy-MM-dd HH:mm:ss")}");
            report.AppendLine();
            
            // Add system information to report
            var totalMemory = processResources.Sum(p => p.MemoryUsageMB);
            var processCount = processResources.Count;
            
            report.AppendLine($"Total processes monitored: {processCount}");
            report.AppendLine($"Total memory usage: {totalMemory:F2} MB");
            report.AppendLine();
            
            // Generate CPU usage ranking
            GenerateResourceRanking(report, processResources, 
                p => p.CpuUsage, "CPU", ConfigurationManager.ProcessCount);
            
            report.AppendLine();
            
            // Generate Memory usage ranking if enabled
            if (ConfigurationManager.ShowMemoryRanking)
            {
                GenerateResourceRanking(report, processResources, 
                    p => p.MemoryUsagePercent, "Memory", ConfigurationManager.ProcessCount);
            }
            
            report.AppendLine();
            report.AppendLine($"Next update will occur at: {DateTime.Now.AddSeconds(ConfigurationManager.MonitorIntervalSeconds).ToString("yyyy-MM-dd HH:mm:ss")}");
            report.AppendLine(new string('=', 100));
            
            return report.ToString();
        }
        
        /// <summary>
        /// Generates a resource usage ranking table for the specified resource
        /// </summary>
        private void GenerateResourceRanking(StringBuilder report, List<ProcessResourceInfo> processes, 
                                          Func<ProcessResourceInfo, double> resourceSelector, 
                                          string resourceName, int count)
        {
            // Sort processes by the specified resource usage and take top N
            var topProcesses = processes
                .OrderByDescending(resourceSelector)
                .Take(count)
                .ToList();
            
            // Add header to report
            report.AppendLine($"Top {count} processes by {resourceName} usage:");
            
            // Determine if we should show detailed info
            if (ConfigurationManager.ShowDetailedProcessInfo)
            {
                report.AppendLine($"{"Rank".PadRight(5)}{"Process Name".PadRight(30)}{"PID".PadRight(10)}{$"{resourceName} (%)".PadRight(12)}{"Memory (MB)".PadRight(15)}{"Start Time".PadRight(20)}{"Description".PadRight(40)}");
                report.AppendLine(new string('-', 132));
                
                // Add each process to report with ranking
                for (int i = 0; i < topProcesses.Count; i++)
                {
                    var proc = topProcesses[i];
                    double resourceValue = resourceSelector(proc);
                    
                    report.AppendLine($"{(i+1).ToString().PadRight(5)}" +
                                    $"{proc.ProcessName.PadRight(30)}" +
                                    $"{proc.ProcessId.ToString().PadRight(10)}" +
                                    $"{resourceValue.ToString("F2").PadRight(12)}" +
                                    $"{proc.MemoryUsageMB.ToString("F2").PadRight(15)}" +
                                    $"{proc.StartTime.PadRight(20)}" +
                                    $"{TruncateString(proc.Description, 40).PadRight(40)}");
                    
                    // If there's a service associated with this process, show it indented on the next line
                    if (!string.IsNullOrEmpty(proc.ServiceName))
                    {
                        report.AppendLine($"     {"Service: " + proc.ServiceName}");
                    }
                }
            }
            else
            {
                // Original simplified display
                report.AppendLine($"{"Rank".PadRight(5)}{"Process Name".PadRight(30)}{"PID".PadRight(10)}{$"{resourceName} (%)".PadRight(12)}{"Memory (MB)".PadRight(15)}{"Start Time".PadRight(20)}");
                report.AppendLine(new string('-', 92));
                
                // Add each process to report with ranking
                for (int i = 0; i < topProcesses.Count; i++)
                {
                    var proc = topProcesses[i];
                    double resourceValue = resourceSelector(proc);
                    
                    report.AppendLine($"{(i+1).ToString().PadRight(5)}" +
                                    $"{proc.ProcessName.PadRight(30)}" +
                                    $"{proc.ProcessId.ToString().PadRight(10)}" +
                                    $"{resourceValue.ToString("F2").PadRight(12)}" +
                                    $"{proc.MemoryUsageMB.ToString("F2").PadRight(15)}" +
                                    $"{proc.StartTime.PadRight(20)}");
                }
            }
        }
        
        /// <summary>
        /// Truncates a string to a maximum length and adds ellipsis if needed
        /// </summary>
        private string TruncateString(string input, int maxLength)
        {
            if (string.IsNullOrEmpty(input))
                return string.Empty;
                
            if (input.Length <= maxLength)
                return input;
                
            return input.Substring(0, maxLength - 3) + "...";
        }
        
        /// <summary>
        /// Output the report to the console
        /// </summary>
        private void OutputToConsole(string reportText)
        {
            try
            {
                Console.Clear();
                Console.WriteLine(reportText);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error writing to console: {ex.Message}");
            }
        }
        
        /// <summary>
        /// Output the report to a log file
        /// </summary>
        private async Task OutputToFileAsync(string reportText, DateTime timestamp, string extension, CancellationToken cancellationToken)
        {
            try
            {
                // Ensure log directory exists
                if (!Directory.Exists(ConfigurationManager.LogFolderPath))
                {
                    try
                    {
                        Directory.CreateDirectory(ConfigurationManager.LogFolderPath);
                        Console.WriteLine($"Created log directory: {ConfigurationManager.LogFolderPath}");
                    }
                    catch (Exception dirEx)
                    {
                        Console.WriteLine($"Failed to create log directory: {dirEx.Message}");
                        return; // Cannot proceed without a log directory
                    }
                }
                
                // Create timestamped filename
                string filename = $"ProcessMonitor_{timestamp.ToString("yyyy-MM-dd")}.{extension}";
                string filePath = Path.Combine(ConfigurationManager.LogFolderPath, filename);
                
                // Write to the file
                using (StreamWriter writer = new StreamWriter(filePath, true, Encoding.UTF8))
                {
                    await writer.WriteLineAsync(reportText);
                    await writer.FlushAsync();
                }
                
                Console.WriteLine($"Report saved to: {filePath}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error writing report to file: {ex.Message}");
            }
        }
        
        /// <summary>
        /// Clean up log files older than the retention period
        /// </summary>
        private async Task CleanupOldLogsAsync(CancellationToken cancellationToken)
        {
            try
            {
                // Calculate the cutoff date for log retention
                DateTime cutoffDate = DateTime.Now.AddDays(-ConfigurationManager.LogRetentionDays);
                
                // Get all log files
                DirectoryInfo logDir = new DirectoryInfo(ConfigurationManager.LogFolderPath);
                if (!logDir.Exists)
                    return;
                
                // Find files older than the cutoff date (both .log and .csv)
                var oldFiles = logDir.GetFiles("ProcessMonitor_*.*")
                    .Where(f => (f.Extension == ".log" || f.Extension == ".csv") && f.LastWriteTime < cutoffDate)
                    .ToList();
                
                if (oldFiles.Count > 0)
                {
                    Console.WriteLine($"Cleaning up {oldFiles.Count} log files older than {ConfigurationManager.LogRetentionDays} days...");
                    
                    // Delete old files
                    foreach (var file in oldFiles)
                    {
                        try
                        {
                            // Check for cancellation
                            cancellationToken.ThrowIfCancellationRequested();
                            
                            // Delete the file
                            file.Delete();
                            
                            // Pause briefly to avoid overwhelming the file system
                            await Task.Delay(20, cancellationToken);
                        }
                        catch (OperationCanceledException)
                        {
                            throw; // Rethrow cancellation exception
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine($"Failed to delete old log file {file.Name}: {ex.Message}");
                        }
                    }
                    
                    Console.WriteLine("Log cleanup completed.");
                }
            }
            catch (OperationCanceledException)
            {
                // Just bubble up cancellation exceptions
                throw;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error during log cleanup: {ex.Message}");
            }
        }
    }
}
```

### 3. 更新 MonitoringEngine.cs 使用新的報告格式

```csharp
using System;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Text;

namespace ProcessMonitor
{
    /// <summary>
    /// Main monitoring engine for processes
    /// </summary>
    public class MonitoringEngine
    {
        /// <summary>
        /// Start the monitoring loop
        /// </summary>
        public async Task StartMonitoringAsync(CancellationToken cancellationToken)
        {
            while (!cancellationToken.IsCancellationRequested)
            {
                // Get current timestamp for this monitoring cycle
                DateTime currentTime = DateTime.Now;
                
                try
                {
                    // Asynchronously collect all process resource information
                    var processCollector = new ProcessCollector();
                    var processResources = await processCollector.CollectProcessResourceInfoAsync(cancellationToken);
                    
                    // Output the report based on configuration settings
                    var reporter = new ReportManager();
                    await reporter.OutputReportAsync(processResources, currentTime, cancellationToken);
                }
                catch (TaskCanceledException)
                {
                    // Normal cancellation, just exit
                    break;
                }
                catch (Exception ex)
                {
                    // Log any errors that occur during the monitoring process
                    Console.WriteLine($"Error during monitoring cycle: {ex.Message}");
                    Console.WriteLine($"Stack trace: {ex.StackTrace}");
                }
                
                // Wait for the next monitoring interval
                try
                {
                    await Task.Delay(ConfigurationManager.MonitorIntervalSeconds * 1000, cancellationToken);
                    
                    // Clear console if configured to output to console
                    if (ConfigurationManager.OutputToConsole)
                        Console.Clear();
                }
                catch (TaskCanceledException)
                {
                    // Normal cancellation, just exit
                    break;
                }
            }
        }
    }
}
```

### 4. 更新 appsettings.json 設定 CSV 輸出格式

```json
{
  "ProcessMonitorSettings": {
    "LogFolderPath": "logs",
    "OutputToConsole": true,
    "OutputToFile": true,
    "MonitorIntervalSeconds": 60,
    "ProcessCount": 10,
    "DetailedCpuMeasurement": true,
    "ShowMemoryRanking": true,
    "ShowDetailedProcessInfo": true,
    "LogRetentionDays": 15,
    "CpuUpdateIntervalMs": 200,
    "OutputFormat": "CSV"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "System": "Warning"
    }
  }
}
```

### 5. 更新 Program.cs 顯示輸出格式設置

```csharp
using System;
using System.Threading;
using System.Threading.Tasks;

namespace ProcessMonitor
{
    class Program
    {
        private static CancellationTokenSource _cancellationTokenSource;

        static async Task Main(string[] args)
        {
            try
            {
                // Initialize application configuration from appsettings.json
                ConfigurationManager.Initialize();
                
                // Create cancellation token source for graceful shutdown
                _cancellationTokenSource = new CancellationTokenSource();

                // Handle Ctrl+C to gracefully exit
                Console.CancelKeyPress += (sender, e) => {
                    e.Cancel = true;
                    _cancellationTokenSource.Cancel();
                    Console.WriteLine("Shutting down...");
                };
                
                // Display startup message
                DisplayStartupInfo();
                
                // Main monitoring loop
                MonitoringEngine monitor = new MonitoringEngine();
                await monitor.StartMonitoringAsync(_cancellationTokenSource.Token);
                
                Console.WriteLine("Process monitor has been shut down.");
            }
            catch (Exception ex)
            {
                // Handle any unhandled exceptions
                Console.WriteLine($"Fatal error: {ex.Message}");
                Console.WriteLine($"Stack trace: {ex.StackTrace}");
                Console.WriteLine("Press any key to exit...");
                Console.ReadKey();
            }
        }
        
        private static void DisplayStartupInfo()
        {
            Console.WriteLine("Process Resource Monitor Started...");
            Console.WriteLine($"Time: {DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss")}");
            Console.WriteLine($"Monitoring top {ConfigurationManager.ProcessCount} processes every {ConfigurationManager.MonitorIntervalSeconds} seconds");
            Console.WriteLine($"Output to console: {ConfigurationManager.OutputToConsole}");
            Console.WriteLine($"Output to file: {ConfigurationManager.OutputToFile}");
            if (ConfigurationManager.OutputToFile)
            {
                Console.WriteLine($"Log folder: {ConfigurationManager.LogFolderPath}");
                Console.WriteLine($"Log retention: {ConfigurationManager.LogRetentionDays} days");
                Console.WriteLine($"Output format: {ConfigurationManager.OutputFormat}");
            }
            Console.WriteLine($"Detailed CPU measurement: {ConfigurationManager.DetailedCpuMeasurement}");
            Console.WriteLine($"CPU update interval: {ConfigurationManager.CpuUpdateIntervalMs}ms");
            Console.WriteLine($"Show memory ranking: {ConfigurationManager.ShowMemoryRanking}");
            Console.WriteLine($"Show detailed process info: {ConfigurationManager.ShowDetailedProcessInfo}");
            Console.WriteLine("Note: Non-administrator privileges may limit access to system processes\n");
        }
    }
}
```

### CSV 輸出功能說明

1. **CSV 格式支援**
   - 新增了 ReportFormat 枚舉，支援 Text 和 CSV 兩種格式
   - 預設設定為 CSV 格式
   - CSV 文件以 .csv 為副檔名，便於在 Excel 或其他電子表格應用程式中打開

2. **CSV 格式結構**
   - 包含時間戳和基本系統資訊的標頭
   - 首先列出按 CPU 使用率排序的進程
   - 如果啟用了記憶體排序，還會包含按記憶體使用率排序的進程
   - 每個進程行包括：排名、進程名稱、PID、CPU %、記憶體 MB、記憶體 %、啟動時間、描述、服務

3. **CSV 格式化**
   - 實現了恰當的 CSV 欄位轉義，處理逗號、引號和換行符
   - 使用不變的文化設定格式化數字，確保全球兼容性
   - 遵循 RFC 4180 標準 CSV 格式

4. **靈活的配置**
   - 使用者可以通過 appsettings.json 在 CSV 和文本格式之間切換
   - 保留了原始的文本格式做為備選

5. **文件管理**
   - 日誌清理功能同時支援 .log 和 .csv 文件
   - 文件名使用日期格式，允許按日期對數據進行組織

這個 CSV 輸出功能使得進程監視資料更容易被匯入到 Excel、資料庫或其他分析工具中，方便進行後續分析或資料視覺化。同時，它保持了與前面實現的日誌保留功能的兼容性。