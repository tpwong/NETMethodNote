了解，那我們可以使用其他方法獲取系統記憶體信息。我將更新代碼以使用標準的 Win32 API 或 .NET 內建的方法來取得總記憶體，而不依賴於 Microsoft.VisualBasic.Devices。

### 更新 ProcessCollector.cs (使用替代方法獲取系統記憶體)

```csharp
using System;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Runtime.InteropServices;

namespace ProcessMonitor
{
    /// <summary>
    /// Responsible for collecting process information
    /// </summary>
    public class ProcessCollector
    {
        // Store system memory information to avoid retrieving it for each process
        private double _totalPhysicalMemoryMB;
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
        private class MEMORYSTATUSEX
        {
            public uint dwLength;
            public uint dwMemoryLoad;
            public ulong ullTotalPhys;
            public ulong ullAvailPhys;
            public ulong ullTotalPageFile;
            public ulong ullAvailPageFile;
            public ulong ullTotalVirtual;
            public ulong ullAvailVirtual;
            public ulong ullAvailExtendedVirtual;
            
            public MEMORYSTATUSEX()
            {
                dwLength = (uint)Marshal.SizeOf(typeof(MEMORYSTATUSEX));
            }
        }
        
        [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool GlobalMemoryStatusEx([In, Out] MEMORYSTATUSEX lpBuffer);
        
        public ProcessCollector()
        {
            // Initialize total system memory on creation
            InitializeSystemInfo();
        }
        
        private void InitializeSystemInfo()
        {
            try
            {
                // Get total physical memory using Windows API
                var memoryStatus = new MEMORYSTATUSEX();
                if (GlobalMemoryStatusEx(memoryStatus))
                {
                    _totalPhysicalMemoryMB = memoryStatus.ullTotalPhys / 1024.0 / 1024.0;
                }
                else
                {
                    // If the API call fails, try alternative method
                    try 
                    {
                        // Alternative approach: Try using PerformanceCounter
                        using (var ramCounter = new PerformanceCounter("Memory", "Available MBytes"))
                        {
                            // This only gives available memory, not total
                            // For simplicity, we'll estimate total based on typical usage
                            var availableMB = ramCounter.NextValue();
                            // Assume system is using ~30% of RAM, so total is roughly available/(1-0.3)
                            _totalPhysicalMemoryMB = availableMB / 0.7;
                        }
                    }
                    catch
                    {
                        // Last resort: Just use a reasonable default value
                        _totalPhysicalMemoryMB = 8192; // 8 GB default
                    }
                }
                
                Console.WriteLine($"Detected total physical memory: {_totalPhysicalMemoryMB:F2} MB");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error retrieving system memory information: {ex.Message}");
                // Fallback to a reasonable value if we can't get the actual memory
                _totalPhysicalMemoryMB = 8192; // 8 GB default
            }
        }
        
        /// <summary>
        /// Asynchronously collect resource usage information for all accessible processes
        /// </summary>
        /// <returns>List of process resource information</returns>
        public async Task<List<ProcessResourceInfo>> CollectProcessResourceInfoAsync(CancellationToken cancellationToken)
        {
            var processResources = new List<ProcessResourceInfo>();
            var processes = Process.GetProcesses();
            
            // Create tasks for all processes
            var tasks = processes.Select(async process => 
            {
                try
                {
                    // Get CPU usage
                    double cpuUsage;
                    if (ConfigurationManager.DetailedCpuMeasurement)
                    {
                        // More accurate CPU measurement
                        cpuUsage = await GetProcessCpuUsageDetailedAsync(process, cancellationToken);
                    }
                    else
                    {
                        // Quick CPU measurement 
                        cpuUsage = GetProcessCpuUsageQuick(process);
                    }
                    
                    // Get memory usage in MB
                    var memoryUsageMB = process.WorkingSet64 / 1024.0 / 1024.0;
                    
                    // Calculate memory usage percentage
                    var memoryUsagePercent = (_totalPhysicalMemoryMB > 0) 
                        ? (memoryUsageMB / _totalPhysicalMemoryMB) * 100 
                        : 0;
                    
                    // Get process start time (if accessible)
                    string startTime = "N/A";
                    try
                    {
                        startTime = process.StartTime.ToString("yyyy-MM-dd HH:mm");
                    }
                    catch
                    {
                        // Some processes may not allow access to their start time
                    }
                    
                    // Return process information
                    return new ProcessResourceInfo
                    {
                        ProcessName = process.ProcessName,
                        ProcessId = process.Id,
                        CpuUsage = cpuUsage,
                        MemoryUsageMB = memoryUsageMB,
                        MemoryUsagePercent = memoryUsagePercent,
                        StartTime = startTime
                    };
                }
                catch (Exception)
                {
                    // Skip processes that can't be accessed due to permissions
                    return null;
                }
                finally
                {
                    // Dispose process object to free resources
                    try { process.Dispose(); } catch { }
                }
            }).ToList();
            
            // Wait for all tasks to complete
            var results = await Task.WhenAll(tasks);
            
            // Filter out null results and return
            return results.Where(p => p != null).ToList();
        }
        
        /// <summary>
        /// Get a quick estimate of CPU usage for processes
        /// </summary>
        private double GetProcessCpuUsageQuick(Process process)
        {
            try
            {
                // Get the current processor time
                TimeSpan totalProcessorTime = process.TotalProcessorTime;
                TimeSpan userProcessorTime = process.UserProcessorTime;
                
                // Calculate an approximate CPU usage based on how long the process has been running
                DateTime startTime;
                try
                {
                    startTime = process.StartTime;
                }
                catch
                {
                    // If we can't get start time, just return 0
                    return 0;
                }
                
                TimeSpan uptime = DateTime.Now - startTime;
                if (uptime.TotalMilliseconds <= 0)
                    return 0;
                
                // Rough estimate: CPU time / uptime / processor count
                return (totalProcessorTime.TotalMilliseconds / uptime.TotalMilliseconds / Environment.ProcessorCount) * 100;
            }
            catch
            {
                return 0;
            }
        }
        
        /// <summary>
        /// Get detailed CPU usage for processes with async/await pattern
        /// </summary>
        private async Task<double> GetProcessCpuUsageDetailedAsync(Process process, CancellationToken cancellationToken)
        {
            try
            {
                // Get initial CPU time and timestamp
                var startTime = DateTime.UtcNow;
                var startCpuUsage = process.TotalProcessorTime;
                
                // Wait for sampling period
                await Task.Delay(100, cancellationToken); // 100ms sampling period
                
                // Get end CPU time and timestamp
                var endTime = DateTime.UtcNow;
                var endCpuUsage = process.TotalProcessorTime;
                
                // Calculate CPU usage percentage
                var cpuUsedMs = (endCpuUsage - startCpuUsage).TotalMilliseconds;
                var totalMsPassed = (endTime - startTime).TotalMilliseconds;
                
                // Adjust for number of CPU cores
                var cpuUsageTotal = cpuUsedMs / (Environment.ProcessorCount * totalMsPassed) * 100;
                
                return cpuUsageTotal;
            }
            catch
            {
                // Return 0 if there was an error calculating CPU usage
                return 0;
            }
        }
    }
}
```

### 更新 csproj 檔案 (移除 Microsoft.VisualBasic 參考)

```xml
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net6.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Configuration" Version="6.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Binder" Version="6.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Json" Version="6.0.0" />
    <PackageReference Include="System.Diagnostics.PerformanceCounter" Version="6.0.0" />
  </ItemGroup>

  <ItemGroup>
    <None Update="appsettings.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>

</Project>
```

### 說明

1. **系統記憶體獲取**：
   - 主要方法：使用 Win32 API 的 `GlobalMemoryStatusEx` 函數獲取系統記憶體信息
   - 備用方法 1：使用 `PerformanceCounter` 類獲取可用記憶體並估算總記憶體
   - 備用方法 2：如果以上方法都失敗，則使用預設值（8GB）

2. **依賴庫更改**：
   - 移除 `Microsoft.VisualBasic` 參考
   - 添加 `System.Diagnostics.PerformanceCounter` 參考（用於備用方法）

3. **新增功能**：
   - 在啟動時顯示偵測到的系統總記憶體
   - 使用多層次的備用方法確保在各種環境下都能工作

這個方法使用了標準的 Win32 API 和 .NET 內建的功能，不需要依賴 Microsoft.