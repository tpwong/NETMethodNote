我了解了，既然 PerformanceCounter 也無法使用，我們可以進一步簡化代碼，只使用 Win32 API 調用來獲取系統記憶體信息，如果失敗就使用默認值。這是最簡單而且可靠的方法，沒有額外的依賴。

### 更新 ProcessCollector.cs (僅使用 Win32 API)

```csharp
using System;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Runtime.InteropServices;

namespace ProcessMonitor
{
    /// <summary>
    /// Responsible for collecting process information
    /// </summary>
    public class ProcessCollector
    {
        // Store system memory information to avoid retrieving it for each process
        private double _totalPhysicalMemoryMB;
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
        private class MEMORYSTATUSEX
        {
            public uint dwLength;
            public uint dwMemoryLoad;
            public ulong ullTotalPhys;
            public ulong ullAvailPhys;
            public ulong ullTotalPageFile;
            public ulong ullAvailPageFile;
            public ulong ullTotalVirtual;
            public ulong ullAvailVirtual;
            public ulong ullAvailExtendedVirtual;
            
            public MEMORYSTATUSEX()
            {
                dwLength = (uint)Marshal.SizeOf(typeof(MEMORYSTATUSEX));
            }
        }
        
        [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool GlobalMemoryStatusEx([In, Out] MEMORYSTATUSEX lpBuffer);
        
        public ProcessCollector()
        {
            // Initialize total system memory on creation
            InitializeSystemInfo();
        }
        
        private void InitializeSystemInfo()
        {
            try
            {
                // Get total physical memory using Windows API
                var memoryStatus = new MEMORYSTATUSEX();
                if (GlobalMemoryStatusEx(memoryStatus))
                {
                    _totalPhysicalMemoryMB = memoryStatus.ullTotalPhys / 1024.0 / 1024.0;
                    Console.WriteLine($"Detected total physical memory: {_totalPhysicalMemoryMB:F2} MB");
                }
                else
                {
                    // If API call fails, use default value
                    _totalPhysicalMemoryMB = 8192; // 8 GB default
                    Console.WriteLine($"Could not detect physical memory. Using default: {_totalPhysicalMemoryMB:F2} MB");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error retrieving system memory information: {ex.Message}");
                // Fallback to a reasonable value if we can't get the actual memory
                _totalPhysicalMemoryMB = 8192; // 8 GB default
                Console.WriteLine($"Using default memory value: {_totalPhysicalMemoryMB:F2} MB");
            }
        }
        
        /// <summary>
        /// Asynchronously collect resource usage information for all accessible processes
        /// </summary>
        /// <returns>List of process resource information</returns>
        public async Task<List<ProcessResourceInfo>> CollectProcessResourceInfoAsync(CancellationToken cancellationToken)
        {
            var processResources = new List<ProcessResourceInfo>();
            var processes = Process.GetProcesses();
            
            // Create tasks for all processes
            var tasks = processes.Select(async process => 
            {
                try
                {
                    // Get CPU usage
                    double cpuUsage;
                    if (ConfigurationManager.DetailedCpuMeasurement)
                    {
                        // More accurate CPU measurement
                        cpuUsage = await GetProcessCpuUsageDetailedAsync(process, cancellationToken);
                    }
                    else
                    {
                        // Quick CPU measurement 
                        cpuUsage = GetProcessCpuUsageQuick(process);
                    }
                    
                    // Get memory usage in MB
                    var memoryUsageMB = process.WorkingSet64 / 1024.0 / 1024.0;
                    
                    // Calculate memory usage percentage
                    var memoryUsagePercent = (_totalPhysicalMemoryMB > 0) 
                        ? (memoryUsageMB / _totalPhysicalMemoryMB) * 100 
                        : 0;
                    
                    // Get process start time (if accessible)
                    string startTime = "N/A";
                    try
                    {
                        startTime = process.StartTime.ToString("yyyy-MM-dd HH:mm");
                    }
                    catch
                    {
                        // Some processes may not allow access to their start time
                    }
                    
                    // Return process information
                    return new ProcessResourceInfo
                    {
                        ProcessName = process.ProcessName,
                        ProcessId = process.Id,
                        CpuUsage = cpuUsage,
                        MemoryUsageMB = memoryUsageMB,
                        MemoryUsagePercent = memoryUsagePercent,
                        StartTime = startTime
                    };
                }
                catch (Exception)
                {
                    // Skip processes that can't be accessed due to permissions
                    return null;
                }
                finally
                {
                    // Dispose process object to free resources
                    try { process.Dispose(); } catch { }
                }
            }).ToList();
            
            // Wait for all tasks to complete
            var results = await Task.WhenAll(tasks);
            
            // Filter out null results and return
            return results.Where(p => p != null).ToList();
        }
        
        /// <summary>
        /// Get a quick estimate of CPU usage for processes
        /// </summary>
        private double GetProcessCpuUsageQuick(Process process)
        {
            try
            {
                // Get the current processor time
                TimeSpan totalProcessorTime = process.TotalProcessorTime;
                TimeSpan userProcessorTime = process.UserProcessorTime;
                
                // Calculate an approximate CPU usage based on how long the process has been running
                DateTime startTime;
                try
                {
                    startTime = process.StartTime;
                }
                catch
                {
                    // If we can't get start time, just return 0
                    return 0;
                }
                
                TimeSpan uptime = DateTime.Now - startTime;
                if (uptime.TotalMilliseconds <= 0)
                    return 0;
                
                // Rough estimate: CPU time / uptime / processor count
                return (totalProcessorTime.TotalMilliseconds / uptime.TotalMilliseconds / Environment.ProcessorCount) * 100;
            }
            catch
            {
                return 0;
            }
        }
        
        /// <summary>
        /// Get detailed CPU usage for processes with async/await pattern
        /// </summary>
        private async Task<double> GetProcessCpuUsageDetailedAsync(Process process, CancellationToken cancellationToken)
        {
            try
            {
                // Get initial CPU time and timestamp
                var startTime = DateTime.UtcNow;
                var startCpuUsage = process.TotalProcessorTime;
                
                // Wait for sampling period
                await Task.Delay(100, cancellationToken); // 100ms sampling period
                
                // Get end CPU time and timestamp
                var endTime = DateTime.UtcNow;
                var endCpuUsage = process.TotalProcessorTime;
                
                // Calculate CPU usage percentage
                var cpuUsedMs = (endCpuUsage - startCpuUsage).TotalMilliseconds;
                var totalMsPassed = (endTime - startTime).TotalMilliseconds;
                
                // Adjust for number of CPU cores
                var cpuUsageTotal = cpuUsedMs / (Environment.ProcessorCount * totalMsPassed) * 100;
                
                return cpuUsageTotal;
            }
            catch
            {
                // Return 0 if there was an error calculating CPU usage
                return 0;
            }
        }
    }
}
```

### 更新 csproj 檔案 (移除所有不需要的依賴)

```xml
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net6.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Configuration" Version="6.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Binder" Version="6.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Json" Version="6.0.0" />
  </ItemGroup>

  <ItemGroup>
    <None Update="appsettings.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>

</Project>
```

### 簡化的方案說明

1. **系統記憶體獲取**：
   - 只使用 Win32 API 的 `GlobalMemoryStatusEx` 函數獲取系統記憶體信息
   - 如果 API 調用失敗，使用預設值 (8GB)
   - 沒有其他依賴或備用方法

2. **改進錯誤處理**：
   - 添加更詳細的錯誤信息輸出
   - 在啟動時清晰地顯示偵測到的記憶體數量或使用的默認值

3. **移除所有額外的依賴**：
   - 不再需要 Microsoft.VisualBasic
   - 不再需要 System.Diagnostics.PerformanceCounter
   - 只保留配置相關的依賴

這是最簡單且可靠的方案，沒有過多的依賴，代碼也更加簡潔。在 Windows 系統上應該能夠正常工作，如果 Win32 API 調用失敗，也有合理的默認值做為備用。

如果你需要這個工具在其他操作系統上運行（例如 Linux 或 macOS），那麼可能需要特定平台的代碼來獲取系統信息。但在 Windows 上，這個方法是最直接的。