CPU 使用率顯示為 0% 可能有幾個原因。讓我們改進 CPU 使用率計算方法，以確保能夠正確顯示進程的 CPU 使用情況。

主要問題可能是：

1. 當前的 CPU 使用率計算方法可能不適用於某些系統或環境
2. 取樣間隔可能太短，無法捕獲有意義的變化
3. 可能存在權限問題，無法正確獲取 CPU 計時資訊

讓我們實現一個更可靠的解決方案：

### 改進 ProcessCollector.cs 的 CPU 使用率計算

```csharp
using System;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.IO;
using Microsoft.Win32;
using System.ComponentModel;
using System.Text;
using System.Collections.Concurrent;

namespace ProcessMonitor
{
    /// <summary>
    /// Responsible for collecting process information
    /// </summary>
    public class ProcessCollector
    {
        // Store system memory information to avoid retrieving it for each process
        private double _totalPhysicalMemoryMB;
        private Dictionary<int, string> _processDescriptions = new Dictionary<int, string>();
        private Dictionary<int, string> _processServices = new Dictionary<int, string>();
        
        // CPU usage tracking
        private ConcurrentDictionary<int, ProcessCpuUsageTracker> _processTrackers = new ConcurrentDictionary<int, ProcessCpuUsageTracker>();
        
        // Win32 API for memory status
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
        private class MEMORYSTATUSEX
        {
            public uint dwLength;
            public uint dwMemoryLoad;
            public ulong ullTotalPhys;
            public ulong ullAvailPhys;
            public ulong ullTotalPageFile;
            public ulong ullAvailPageFile;
            public ulong ullTotalVirtual;
            public ulong ullAvailVirtual;
            public ulong ullAvailExtendedVirtual;
            
            public MEMORYSTATUSEX()
            {
                dwLength = (uint)Marshal.SizeOf(typeof(MEMORYSTATUSEX));
            }
        }
        
        [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool GlobalMemoryStatusEx([In, Out] MEMORYSTATUSEX lpBuffer);
        
        // Win32 API for getting system times
        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern bool GetSystemTimes(out long idleTime, out long kernelTime, out long userTime);
        
        // Win32 API for services querying
        [StructLayout(LayoutKind.Sequential)]
        private struct SERVICE_STATUS_PROCESS
        {
            public int dwServiceType;
            public int dwCurrentState;
            public int dwControlsAccepted;
            public int dwWin32ExitCode;
            public int dwServiceSpecificExitCode;
            public int dwCheckPoint;
            public int dwWaitHint;
            public int dwProcessId;
            public int dwServiceFlags;
        }
        
        [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        private static extern IntPtr OpenSCManager(string lpMachineName, string lpDatabaseName, int dwDesiredAccess);
        
        [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        private static extern IntPtr OpenService(IntPtr hSCManager, string lpServiceName, int dwDesiredAccess);
        
        [DllImport("advapi32.dll", SetLastError = true)]
        private static extern bool QueryServiceStatusEx(IntPtr hService, int infoLevel, IntPtr lpBuffer, int cbBufSize, out int pcbBytesNeeded);
        
        [DllImport("advapi32.dll", SetLastError = true)]
        private static extern bool CloseServiceHandle(IntPtr hSCObject);
        
        [DllImport("advapi32.dll", EntryPoint = "EnumServicesStatusExW", SetLastError = true, CharSet = CharSet.Unicode)]
        private static extern bool EnumServicesStatusEx(
            IntPtr hSCManager,
            int infoLevel,
            int dwServiceType,
            int dwServiceState,
            IntPtr lpServices,
            int cbBufSize,
            out int pcbBytesNeeded,
            out int lpServicesReturned,
            ref int lpResumeHandle,
            string pszGroupName);
            
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        private struct ENUM_SERVICE_STATUS_PROCESS
        {
            public string lpServiceName;
            public string lpDisplayName;
            public SERVICE_STATUS_PROCESS ServiceStatusProcess;
        }
        
        // Constants for service API
        private const int SC_MANAGER_CONNECT = 0x0001;
        private const int SC_MANAGER_ENUMERATE_SERVICE = 0x0004;
        private const int SERVICE_QUERY_STATUS = 0x0004;
        private const int SERVICE_WIN32 = 0x00000030;
        private const int SERVICE_ACTIVE = 0x00000001;
        private const int SC_STATUS_PROCESS_INFO = 0;
        private const int SC_ENUM_PROCESS_INFO = 0;
        
        /// <summary>
        /// Internal class to track CPU usage over time for a process
        /// </summary>
        private class ProcessCpuUsageTracker
        {
            private DateTime _lastUpdateTime;
            private TimeSpan _lastTotalProcessorTime;
            private double _cpuUsage;
            private bool _isInitialized;
            
            public ProcessCpuUsageTracker()
            {
                _lastUpdateTime = DateTime.UtcNow;
                _lastTotalProcessorTime = TimeSpan.Zero;
                _cpuUsage = 0;
                _isInitialized = false;
            }
            
            public double UpdateCpuUsage(Process process)
            {
                try
                {
                    DateTime currentUpdateTime = DateTime.UtcNow;
                    TimeSpan currentTotalProcessorTime = process.TotalProcessorTime;
                    
                    if (_isInitialized)
                    {
                        // Calculate CPU usage
                        double elapsedSeconds = (currentUpdateTime - _lastUpdateTime).TotalSeconds;
                        
                        if (elapsedSeconds > 0)
                        {
                            double cpuUsedMs = (currentTotalProcessorTime - _lastTotalProcessorTime).TotalMilliseconds;
                            // CPU usage % = (CPU time used in period) / (period length * processor count) * 100
                            _cpuUsage = (cpuUsedMs / (elapsedSeconds * 1000 * Environment.ProcessorCount)) * 100;
                            // Cap at 100% per core
                            _cpuUsage = Math.Min(_cpuUsage, 100 * Environment.ProcessorCount);
                        }
                    }
                    else
                    {
                        _isInitialized = true;
                    }
                    
                    // Update previous values for next calculation
                    _lastUpdateTime = currentUpdateTime;
                    _lastTotalProcessorTime = currentTotalProcessorTime;
                    
                    return _cpuUsage;
                }
                catch
                {
                    // If we can't get the CPU time, return the last known value or 0
                    return _isInitialized ? _cpuUsage : 0;
                }
            }
        }
        
        public ProcessCollector()
        {
            // Initialize total system memory on creation
            InitializeSystemInfo();
            
            // Pre-load process descriptions and service relationships
            LoadProcessDescriptions();
            LoadServiceProcesses();
            
            // Pre-initialize process trackers
            InitializeProcessTrackers();
        }
        
        /// <summary>
        /// Initialize CPU usage trackers for all processes
        /// </summary>
        private void InitializeProcessTrackers()
        {
            try
            {
                foreach (var process in Process.GetProcesses())
                {
                    try
                    {
                        _processTrackers[process.Id] = new ProcessCpuUsageTracker();
                    }
                    catch { }
                    finally
                    {
                        process.Dispose();
                    }
                }
                
                // Do an initial measurement to initialize values
                foreach (var processId in _processTrackers.Keys.ToList())
                {
                    try
                    {
                        using (var process = Process.GetProcessById(processId))
                        {
                            _processTrackers[processId].UpdateCpuUsage(process);
                        }
                    }
                    catch
                    {
                        // Process may no longer exist, remove tracker
                        _processTrackers.TryRemove(processId, out _);
                    }
                }
                
                // Wait a moment to get a first real reading
                Thread.Sleep(200);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Warning: Error initializing process trackers: {ex.Message}");
            }
        }
        
        private void InitializeSystemInfo()
        {
            try
            {
                // Get total physical memory using Windows API
                var memoryStatus = new MEMORYSTATUSEX();
                if (GlobalMemoryStatusEx(memoryStatus))
                {
                    _totalPhysicalMemoryMB = memoryStatus.ullTotalPhys / 1024.0 / 1024.0;
                    Console.WriteLine($"Detected total physical memory: {_totalPhysicalMemoryMB:F2} MB");
                }
                else
                {
                    // If API call fails, use default value
                    _totalPhysicalMemoryMB = 8192; // 8 GB default
                    Console.WriteLine($"Could not detect physical memory. Using default: {_totalPhysicalMemoryMB:F2} MB");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error retrieving system memory information: {ex.Message}");
                // Fallback to a reasonable value if we can't get the actual memory
                _totalPhysicalMemoryMB = 8192; // 8 GB default
                Console.WriteLine($"Using default memory value: {_totalPhysicalMemoryMB:F2} MB");
            }
        }
        
        /// <summary>
        /// Loads process descriptions from file information
        /// </summary>
        private void LoadProcessDescriptions()
        {
            try
            {
                foreach (var process in Process.GetProcesses())
                {
                    try
                    {
                        string description = GetFileDescription(process);
                        if (!string.IsNullOrEmpty(description))
                        {
                            _processDescriptions[process.Id] = description;
                        }
                        else
                        {
                            // If no description is found, use the process name
                            _processDescriptions[process.Id] = process.ProcessName;
                        }
                    }
                    catch { }
                    finally
                    {
                        process.Dispose();
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Warning: Could not load process descriptions: {ex.Message}");
            }
        }
        
        /// <summary>
        /// Gets file description for a process
        /// </summary>
        private string GetFileDescription(Process process)
        {
            try
            {
                string filename = null;
                try
                {
                    filename = process.MainModule?.FileName;
                }
                catch
                {
                    // Some processes won't allow access to their modules
                    return process.ProcessName;
                }
                
                if (string.IsNullOrEmpty(filename))
                    return process.ProcessName;
                
                // Get file description from version info
                FileVersionInfo versionInfo = FileVersionInfo.GetVersionInfo(filename);
                
                if (!string.IsNullOrEmpty(versionInfo.FileDescription))
                    return versionInfo.FileDescription;
                
                // If no description, return the filename
                return Path.GetFileName(filename);
            }
            catch
            {
                return process.ProcessName;
            }
        }
        
        /// <summary>
        /// Loads the mapping between services and their processes using Windows API
        /// </summary>
        private void LoadServiceProcesses()
        {
            var servicesToPID = new Dictionary<string, int>(); // service name to PID
            var serviceDisplayNames = new Dictionary<string, string>(); // service name to display name
            
            try
            {
                // Open the service control manager
                IntPtr scmHandle = OpenSCManager(null, null, SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE);
                if (scmHandle == IntPtr.Zero)
                {
                    int error = Marshal.GetLastWin32Error();
                    Console.WriteLine($"Failed to open service manager: {new Win32Exception(error).Message}");
                    return;
                }
                
                try
                {
                    // First call to get required buffer size
                    int bytesNeeded = 0;
                    int servicesReturned = 0;
                    int resumeHandle = 0;
                    
                    EnumServicesStatusEx(
                        scmHandle,
                        SC_ENUM_PROCESS_INFO,
                        SERVICE_WIN32,
                        SERVICE_ACTIVE,
                        IntPtr.Zero,
                        0,
                        out bytesNeeded,
                        out servicesReturned,
                        ref resumeHandle,
                        null);
                    
                    if (bytesNeeded == 0)
                    {
                        Console.WriteLine("No services found or buffer size estimation failed.");
                        return;
                    }
                    
                    // Allocate the buffer and call again
                    IntPtr servicesBuffer = Marshal.AllocHGlobal(bytesNeeded);
                    
                    try
                    {
                        resumeHandle = 0;
                        
                        if (EnumServicesStatusEx(
                            scmHandle,
                            SC_ENUM_PROCESS_INFO,
                            SERVICE_WIN32,
                            SERVICE_ACTIVE,
                            servicesBuffer,
                            bytesNeeded,
                            out bytesNeeded,
                            out servicesReturned,
                            ref resumeHandle,
                            null))
                        {
                            // Marshal the buffer to the structure array
                            int structSize = Marshal.SizeOf(typeof(ENUM_SERVICE_STATUS_PROCESS));
                            
                            for (int i = 0; i < servicesReturned; i++)
                            {
                                IntPtr structPtr = new IntPtr(servicesBuffer.ToInt64() + i * structSize);
                                ENUM_SERVICE_STATUS_PROCESS serviceStatus = (ENUM_SERVICE_STATUS_PROCESS)Marshal.PtrToStructure(structPtr, typeof(ENUM_SERVICE_STATUS_PROCESS));
                                
                                // Store the service-to-PID mapping
                                if (serviceStatus.ServiceStatusProcess.dwProcessId > 0)
                                {
                                    servicesToPID[serviceStatus.lpServiceName] = serviceStatus.ServiceStatusProcess.dwProcessId;
                                    serviceDisplayNames[serviceStatus.lpServiceName] = serviceStatus.lpDisplayName;
                                }
                            }
                        }
                    }
                    finally
                    {
                        Marshal.FreeHGlobal(servicesBuffer);
                    }
                }
                finally
                {
                    CloseServiceHandle(scmHandle);
                }
                
                // Now invert the mapping to create PID-to-ServiceName dictionary
                foreach (var pair in servicesToPID)
                {
                    string serviceName = pair.Key;
                    int pid = pair.Value;
                    string displayName = serviceDisplayNames.ContainsKey(serviceName) ? serviceDisplayNames[serviceName] : serviceName;
                    
                    if (_processServices.ContainsKey(pid))
                    {
                        if (!_processServices[pid].Contains(displayName))
                            _processServices[pid] += ", " + displayName;
                    }
                    else
                    {
                        _processServices[pid] = displayName;
                    }
                }
                
                Console.WriteLine($"Loaded service information for {servicesToPID.Count} services");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Warning: Could not load service information: {ex.Message}");
            }
        }
        
        /// <summary>
        /// Asynchronously collect resource usage information for all accessible processes
        /// </summary>
        /// <returns>List of process resource information</returns>
        public async Task<List<ProcessResourceInfo>> CollectProcessResourceInfoAsync(CancellationToken cancellationToken)
        {
            var processResources = new List<ProcessResourceInfo>();
            var processes = Process.GetProcesses();
            
            // Create tasks for all processes
            var tasks = processes.Select(async process => 
            {
                try
                {
                    // Get CPU usage using our persistent tracker
                    double cpuUsage = GetCpuUsage(process);
                    
                    // Get memory usage in MB
                    var memoryUsageMB = process.WorkingSet64 / 1024.0 / 1024.0;
                    
                    // Calculate memory usage percentage
                    var memoryUsagePercent = (_totalPhysicalMemoryMB > 0) 
                        ? (memoryUsageMB / _totalPhysicalMemoryMB) * 100 
                        : 0;
                    
                    // Get process start time (if accessible)
                    string startTime = "N/A";
                    try
                    {
                        startTime = process.StartTime.ToString("yyyy-MM-dd HH:mm");
                    }
                    catch
                    {
                        // Some processes may not allow access to their start time
                    }
                    
                    // Get process description
                    string description = "N/A";
                    if (_processDescriptions.ContainsKey(process.Id))
                        description = _processDescriptions[process.Id];
                    
                    // Get service name
                    string serviceName = string.Empty;
                    if (_processServices.ContainsKey(process.Id))
                        serviceName = _processServices[process.Id];
                    
                    // Return process information
                    return new ProcessResourceInfo
                    {
                        ProcessName = process.ProcessName,
                        ProcessId = process.Id,
                        CpuUsage = cpuUsage,
                        MemoryUsageMB = memoryUsageMB,
                        MemoryUsagePercent = memoryUsagePercent,
                        StartTime = startTime,
                        Description = description,
                        ServiceName = serviceName
                    };
                }
                catch (Exception)
                {
                    // Skip processes that can't be accessed due to permissions
                    return null;
                }
                finally
                {
                    // Dispose process object to free resources
                    try { process.Dispose(); } catch { }
                }
            }).ToList();
            
            // Wait for all tasks to complete
            var results = await Task.WhenAll(tasks);
            
            // Filter out null results and return
            return results.Where(p => p != null).ToList();
        }
        
        /// <summary>
        /// Get CPU usage for a process using persistent trackers
        /// </summary>
        private double GetCpuUsage(Process process)
        {
            try
            {
                // Get or create the tracker for this process
                var tracker = _processTrackers.GetOrAdd(process.Id, _ => new ProcessCpuUsageTracker());
                
                // Update and get the CPU usage
                return tracker.UpdateCpuUsage(process);
            }
            catch
            {
                return 0;
            }
        }
    }
}
```

### 更新 ConfigurationManager.cs 添加重要的 CPU 相關設定

```csharp
using System;
using System.Collections.Generic;
using System.IO;
using Microsoft.Extensions.Configuration;

namespace ProcessMonitor
{
    /// <summary>
    /// Manages application configuration settings from appsettings.json
    /// </summary>
    public static class ConfigurationManager
    {
        private static IConfiguration _configuration;
        
        // Configuration settings
        public static string LogFolderPath { get; private set; }
        public static bool OutputToConsole { get; private set; }
        public static bool OutputToFile { get; private set; }
        public static int MonitorIntervalSeconds { get; private set; }
        public static int ProcessCount { get; private set; }
        public static bool DetailedCpuMeasurement { get; private set; }
        public static bool ShowMemoryRanking { get; private set; }
        public static bool ShowDetailedProcessInfo { get; private set; }
        public static int LogRetentionDays { get; private set; }
        public static int CpuUpdateIntervalMs { get; private set; }

        /// <summary>
        /// Initialize configuration settings from appsettings.json
        /// </summary>
        public static void Initialize()
        {
            try
            {
                // Build configuration from appsettings.json
                _configuration = new ConfigurationBuilder()
                    .SetBasePath(Directory.GetCurrentDirectory())
                    .AddJsonFile("appsettings.json", optional: false, reloadOnChange: true)
                    .Build();
                
                // Get "ProcessMonitorSettings" section
                var settings = _configuration.GetSection("ProcessMonitorSettings");
                
                // Read config values with defaults
                LogFolderPath = settings["LogFolderPath"] ?? 
                    Path.Combine(Directory.GetCurrentDirectory(), "logs");
                    
                OutputToConsole = settings.GetValue<bool?>("OutputToConsole") ?? true;
                OutputToFile = settings.GetValue<bool?>("OutputToFile") ?? true;
                MonitorIntervalSeconds = settings.GetValue<int?>("MonitorIntervalSeconds") ?? 60;
                ProcessCount = settings.GetValue<int?>("ProcessCount") ?? 10;
                DetailedCpuMeasurement = settings.GetValue<bool?>("DetailedCpuMeasurement") ?? true;
                ShowMemoryRanking = settings.GetValue<bool?>("ShowMemoryRanking") ?? true;
                ShowDetailedProcessInfo = settings.GetValue<bool?>("ShowDetailedProcessInfo") ?? true;
                LogRetentionDays = settings.GetValue<int?>("LogRetentionDays") ?? 15;
                CpuUpdateIntervalMs = settings.GetValue<int?>("CpuUpdateIntervalMs") ?? 200;
                
                // Validate settings
                if (LogRetentionDays < 1)
                {
                    Console.WriteLine("Warning: LogRetentionDays must be at least 1. Setting to default (15).");
                    LogRetentionDays = 15;
                }
                
                if (CpuUpdateIntervalMs < 100)
                {
                    Console.WriteLine("Warning: CpuUpdateIntervalMs must be at least 100ms. Setting to default (200ms).");
                    CpuUpdateIntervalMs = 200;
                }
                
                // Ensure log directory exists if we're outputting to file
                if (OutputToFile && !Directory.Exists(LogFolderPath))
                {
                    Directory.CreateDirectory(LogFolderPath);
                    Console.WriteLine($"Created log directory: {LogFolderPath}");
                }
            }
            catch (Exception ex)
            {
                // If there's an error reading config, use default values and log the error
                Console.WriteLine($"Error reading configuration: {ex.Message}. Using default values.");
                
                // Set default values
                LogFolderPath = Path.Combine(Directory.GetCurrentDirectory(), "logs");
                OutputToConsole = true;
                OutputToFile = true;
                MonitorIntervalSeconds = 60;
                ProcessCount = 10;
                DetailedCpuMeasurement = true;
                ShowMemoryRanking = true;
                ShowDetailedProcessInfo = true;
                LogRetentionDays = 15;
                CpuUpdateIntervalMs = 200;
                
                // Create logs directory with default values
                try
                {
                    if (OutputToFile && !Directory.Exists(LogFolderPath))
                    {
                        Directory.CreateDirectory(LogFolderPath);
                        Console.WriteLine($"Created log directory: {LogFolderPath}");
                    }
                }
                catch (Exception dirEx)
                {
                    Console.WriteLine($"Failed to create log directory: {dirEx.Message}");
                } 
            }
        }
        
        /// <summary>
        /// Gets the raw configuration object for advanced usage
        /// </summary>
        public static IConfiguration GetRawConfiguration()
        {
            return _configuration;
        }
    }
}
```

### 更新 appsettings.json 添加 CPU 更新間隔設定

```json
{
  "ProcessMonitorSettings": {
    "LogFolderPath": "logs",
    "OutputToConsole": true,
    "OutputToFile": true,
    "MonitorIntervalSeconds": 60,
    "ProcessCount": 10,
    "DetailedCpuMeasurement": true,
    "ShowMemoryRanking": true,
    "ShowDetailedProcessInfo": true,
    "LogRetentionDays": 15,
    "CpuUpdateIntervalMs": 200
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "System": "Warning"
    }
  }
}
```

### 更新 Program.cs 顯示 CPU 測量設置

```csharp
using System;
using System.Threading;
using System.Threading.Tasks;

namespace ProcessMonitor
{
    class Program
    {
        private static CancellationTokenSource _cancellationTokenSource;

        static async Task Main(string[] args)
        {
            try
            {
                // Initialize application configuration from appsettings.json
                ConfigurationManager.Initialize();
                
                // Create cancellation token source for graceful shutdown
                _cancellationTokenSource = new CancellationTokenSource();

                // Handle Ctrl+C to gracefully exit
                Console.CancelKeyPress += (sender, e) => {
                    e.Cancel = true;
                    _cancellationTokenSource.Cancel();
                    Console.WriteLine("Shutting down...");
                };
                
                // Display startup message
                DisplayStartupInfo();
                
                // Main monitoring loop
                MonitoringEngine monitor = new MonitoringEngine();
                await monitor.StartMonitoringAsync(_cancellationTokenSource.Token);
                
                Console.WriteLine("Process monitor has been shut down.");
            }
            catch (Exception ex)
            {
                // Handle any unhandled exceptions
                Console.WriteLine($"Fatal error: {ex.Message}");
                Console.WriteLine($"Stack trace: {ex.StackTrace}");
                Console.WriteLine("Press any key to exit...");
                Console.ReadKey();
            }
        }
        
        private static void DisplayStartupInfo()
        {
            Console.WriteLine("Process Resource Monitor Started...");
            Console.WriteLine($"Time: {DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss")}");
            Console.WriteLine($"Monitoring top {ConfigurationManager.ProcessCount} processes every {ConfigurationManager.MonitorIntervalSeconds} seconds");
            Console.WriteLine($"Output to console: {ConfigurationManager.OutputToConsole}");
            Console.WriteLine($"Output to file: {ConfigurationManager.OutputToFile}");
            if (ConfigurationManager.OutputToFile)
            {
                Console.WriteLine($"Log folder: {ConfigurationManager.LogFolderPath}");
                Console.WriteLine($"Log retention: {ConfigurationManager.LogRetentionDays} days");
            }
            Console.WriteLine($"Detailed CPU measurement: {ConfigurationManager.DetailedCpuMeasurement}");
            Console.WriteLine($"CPU update interval: {ConfigurationManager.CpuUpdateIntervalMs}ms");
            Console.WriteLine($"Show memory ranking: {ConfigurationManager.ShowMemoryRanking}");
            Console.WriteLine($"Show detailed process info: {ConfigurationManager.ShowDetailedProcessInfo}");
            Console.WriteLine("Note: Non-administrator privileges may limit access to system processes\n");
        }
    }
}
```

### 改進說明

1. **持久性 CPU 使用率追蹤**
   - 新增 `ProcessCpuUsageTracker` 類別來持續追蹤進程的 CPU 使用
   - 維護每個進程 ID 的最後處理器時間和時間戳
   - 使用 `ConcurrentDictionary` 儲存追蹤器，確保線程安全

2. **更準確的 CPU 使用率計算**
   - 使用進程總處理器時間的差異來計算 CPU 使用
   - 考慮系統 CPU 核心數，確保報告正確的百分比
   - 為新的進程初始化追蹤器，確保已有基準測量

3. **配置選項**
   - 新增 `CpuUpdateIntervalMs` 配置選項，讓使用者可調整 CPU 測量的更新頻率
   - 預設為 200ms，這應該足夠準確但不會過度消耗系統資源

4. **啟動優化**
   - 在啟動時預初始化所有進程的 CPU 使用率追蹤器
   - 等待一段時間後進行初始測量，確保有合理的初始值

5. **異常處理**
   - 改進的錯誤處理，確保當無法訪問某些進程時不會崩潰
   - 如果進程消失，自動從追蹤器集合中移除

這些改進應該會解決 CPU 使用率顯示為 0% 的問題，提供更準確、持續的 CPU 使用率測量。新的方法通過跟踪每個進程在連續監測間隔之間使用的 CPU 時間，從而確保即使是短暫的 CPU 活動也能被捕獲和報告。

這種方法特別適合監測長時間運行的進程，因為它會累積一段時間內的 CPU 使用情況，而不只是基於單個快照。