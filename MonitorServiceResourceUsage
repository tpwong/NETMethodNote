好的，我將代碼修改為使用`appsettings.json`而不是傳統的`App.config`。這是.NET Core和.NET 5+中的標準方式。

### 首先，創建appsettings.json文件：

```json
{
  "ProcessMonitorSettings": {
    "LogFolderPath": "C:\\ProcessMonitorLogs",
    "OutputToConsole": true,
    "OutputToFile": true,
    "MonitorIntervalSeconds": 60,
    "ProcessCount": 10,
    "TargetServicePatterns": [
      "MyService",
      "WebApi",
      "Worker", 
      "Api",
      "DataProcessor",
      "ServiceHost"
    ]
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "System": "Warning"
    }
  }
}
```

### 然後，修改配置管理器以使用appsettings.json：

### 1. ConfigurationManager.cs

```csharp
using System;
using System.Linq;
using System.Collections.Generic;
using System.IO;
using Microsoft.Extensions.Configuration;

namespace ProcessMonitor
{
    /// <summary>
    /// Manages application configuration settings from appsettings.json
    /// </summary>
    public static class ConfigurationManager
    {
        private static IConfiguration _configuration;
        
        // Configuration settings
        public static string LogFolderPath { get; private set; }
        public static bool OutputToConsole { get; private set; }
        public static bool OutputToFile { get; private set; }
        public static int MonitorIntervalSeconds { get; private set; }
        public static int ProcessCount { get; private set; }
        public static List<string> TargetServicePatterns { get; private set; }

        /// <summary>
        /// Initialize configuration settings from appsettings.json
        /// </summary>
        public static void Initialize()
        {
            try
            {
                // Build configuration from appsettings.json
                _configuration = new ConfigurationBuilder()
                    .SetBasePath(Directory.GetCurrentDirectory())
                    .AddJsonFile("appsettings.json", optional: false, reloadOnChange: true)
                    .Build();
                
                // Get "ProcessMonitorSettings" section
                var settings = _configuration.GetSection("ProcessMonitorSettings");
                
                // Read config values with defaults
                LogFolderPath = settings["LogFolderPath"] ?? 
                    Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Logs");
                    
                OutputToConsole = settings.GetValue<bool?>("OutputToConsole") ?? true;
                OutputToFile = settings.GetValue<bool?>("OutputToFile") ?? true;
                MonitorIntervalSeconds = settings.GetValue<int?>("MonitorIntervalSeconds") ?? 60;
                ProcessCount = settings.GetValue<int?>("ProcessCount") ?? 10;
                
                // Read target service patterns
                TargetServicePatterns = settings.GetSection("TargetServicePatterns")
                    .Get<List<string>>() ?? 
                    new List<string> { "MyService", "WebApi", "Worker" };
                
                // Ensure log directory exists if we're outputting to file
                if (OutputToFile && !Directory.Exists(LogFolderPath))
                    Directory.CreateDirectory(LogFolderPath);
            }
            catch (Exception ex)
            {
                // If there's an error reading config, use default values and log the error
                Console.WriteLine($"Error reading configuration: {ex.Message}. Using default values.");
                
                // Set default values
                LogFolderPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Logs");
                OutputToConsole = true;
                OutputToFile = true;
                MonitorIntervalSeconds = 60;
                ProcessCount = 10;
                TargetServicePatterns = new List<string> { "MyService", "WebApi", "Worker" };
                
                // Create logs directory with default values
                try
                {
                    if (OutputToFile && !Directory.Exists(LogFolderPath))
                        Directory.CreateDirectory(LogFolderPath);
                }
                catch { }
            }
        }
    }
}
```

### 2. 修改Program.cs以反映使用appsettings.json

```csharp
using System;
using System.Threading;
using System.Threading.Tasks;
using System.Text;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

namespace ProcessMonitor
{
    class Program
    {
        private static CancellationTokenSource _cancellationTokenSource;

        static async Task Main(string[] args)
        {
            try
            {
                // Initialize application configuration from appsettings.json
                ConfigurationManager.Initialize();
                
                // Create cancellation token source for graceful shutdown
                _cancellationTokenSource = new CancellationTokenSource();

                // Handle Ctrl+C to gracefully exit
                Console.CancelKeyPress += (sender, e) => {
                    e.Cancel = true;
                    _cancellationTokenSource.Cancel();
                    Console.WriteLine("Shutting down...");
                };
                
                // Display startup message
                DisplayStartupInfo();
                
                // Main monitoring loop
                MonitoringEngine monitor = new MonitoringEngine();
                await monitor.StartMonitoringAsync(_cancellationTokenSource.Token);
                
                Console.WriteLine("Process monitor has been shut down.");
            }
            catch (Exception ex)
            {
                // Handle any unhandled exceptions
                Console.WriteLine($"Fatal error: {ex.Message}");
                Console.WriteLine($"Stack trace: {ex.StackTrace}");
                Console.WriteLine("Press any key to exit...");
                Console.ReadKey();
            }
        }
        
        private static void DisplayStartupInfo()
        {
            Console.WriteLine("Process Resource Monitor Started...");
            Console.WriteLine($"Time: {DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss")}");
            Console.WriteLine($"Monitoring top {ConfigurationManager.ProcessCount} processes every {ConfigurationManager.MonitorIntervalSeconds} seconds");
            Console.WriteLine($"Output to console: {ConfigurationManager.OutputToConsole}");
            Console.WriteLine($"Output to file: {ConfigurationManager.OutputToFile}");
            if (ConfigurationManager.OutputToFile)
                Console.WriteLine($"Log folder: {ConfigurationManager.LogFolderPath}");
            Console.WriteLine($"Target service patterns: {string.Join(", ", ConfigurationManager.TargetServicePatterns)}");
            Console.WriteLine("Note: Non-administrator privileges may limit access to system processes\n");
        }
    }
}
```

### 3. 其餘文件保持不變

ProcessCollector.cs、ReportManager.cs、MonitoringEngine.cs和ProcessResourceInfo.cs的代碼保持不變，因為它們不直接處理配置，而是通過ConfigurationManager類訪問配置。

### 更新項目文件（.csproj）以包含所需的NuGet包：

```xml
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net6.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Configuration" Version="6.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Binder" Version="6.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Json" Version="6.0.0" />
  </ItemGroup>

  <ItemGroup>
    <None Update="appsettings.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>

</Project>
```

### 重要說明：

1. **需要安裝的NuGet包**：
   - Microsoft.Extensions.Configuration
   - Microsoft.Extensions.Configuration.Json
   - Microsoft.Extensions.Configuration.Binder

2. **確保appsettings.json被複製到輸出目錄**：
   - 在Visual Studio中，右鍵單擊appsettings.json
   - 選擇"屬性"
   - 將"複製到輸出目錄"設置為"如果較新則複製"

3. **文件位置**：
   - appsettings.json應該放在項目的根目錄中
   - 確保它正確跟踪在版本控制中

使用appsettings.json的好處：

1. **結構化配置**：JSON格式更加結構化和階層化
2. **現代標準**：這是.NET Core和.NET 5+的標準配置方式
3. **運行時重載**：設置`reloadOnChange: true`可以讓應用在配置文件變更時自動重新加載
4. **更好的集成**：與ASP.NET Core和其他現代.NET功能更好地集成
5. **類型化配置**：可以將配置節直接綁定到強類型對象

這樣的改動使得您的應用程序更加現代化，並與最新的.NET最佳實踐保持一致。